import ceylon.json {
  JsonObject=Object,
  JsonArray=Array,
  parse
}
import io.vertx.lang.ceylon {
  BaseDataObject,
  Converter,
  ToJava
}
import io.vertx.ceylon.sql {
  FetchDirection,
  fetchDirection_=fetchDirection,
  ResultSetConcurrency,
  resultSetConcurrency_=resultSetConcurrency,
  ResultSetType,
  resultSetType_=resultSetType,
  TransactionIsolation,
  transactionIsolation_=transactionIsolation
}
import io.vertx.ext.sql {
  SQLOptions_=SQLOptions
}
import ceylon.collection {
  HashMap
}
import io.vertx.core.json {
  JsonObject_=JsonObject,
  JsonArray_=JsonArray
}
/* Generated from io.vertx.ext.sql.SQLOptions */
" Represents the options one can use to customize the unwrapped connection/statement/resultset types\n"
shared class SQLOptions(
  shared Boolean? autoGeneratedKeys = null,
  shared JsonArray? autoGeneratedKeysIndexes = null,
  shared String? catalog = null,
  shared FetchDirection? fetchDirection = null,
  shared Integer? fetchSize = null,
  shared Integer? queryTimeout = null,
  shared Boolean? readOnly = null,
  shared ResultSetConcurrency? resultSetConcurrency = null,
  shared ResultSetType? resultSetType = null,
  shared String? schema = null,
  shared TransactionIsolation? transactionIsolation = null) satisfies BaseDataObject {
  shared actual default JsonObject toJson() {
    value json = JsonObject();
    if (exists autoGeneratedKeys) {
      json.put("autoGeneratedKeys", autoGeneratedKeys);
    }
    if (exists autoGeneratedKeysIndexes) {
      json.put("autoGeneratedKeysIndexes", autoGeneratedKeysIndexes);
    }
    if (exists catalog) {
      json.put("catalog", catalog);
    }
    if (exists fetchDirection) {
      json.put("fetchDirection", fetchDirection_.toString(fetchDirection));
    }
    if (exists fetchSize) {
      json.put("fetchSize", fetchSize);
    }
    if (exists queryTimeout) {
      json.put("queryTimeout", queryTimeout);
    }
    if (exists readOnly) {
      json.put("readOnly", readOnly);
    }
    if (exists resultSetConcurrency) {
      json.put("resultSetConcurrency", resultSetConcurrency_.toString(resultSetConcurrency));
    }
    if (exists resultSetType) {
      json.put("resultSetType", resultSetType_.toString(resultSetType));
    }
    if (exists schema) {
      json.put("schema", schema);
    }
    if (exists transactionIsolation) {
      json.put("transactionIsolation", transactionIsolation_.toString(transactionIsolation));
    }
    return json;
  }
}

shared object sqlOptions {

  shared SQLOptions fromJson(JsonObject json) {
    Boolean? autoGeneratedKeys = json.getBooleanOrNull("autoGeneratedKeys");
    JsonArray? autoGeneratedKeysIndexes = json.getArrayOrNull("autoGeneratedKeysIndexes");
    String? catalog = json.getStringOrNull("catalog");
    FetchDirection? fetchDirection = if (exists tmp = json.getStringOrNull("fetchDirection")) then fetchDirection_.fromString(tmp) else null;
    Integer? fetchSize = json.getIntegerOrNull("fetchSize");
    Integer? queryTimeout = json.getIntegerOrNull("queryTimeout");
    Boolean? readOnly = json.getBooleanOrNull("readOnly");
    ResultSetConcurrency? resultSetConcurrency = if (exists tmp = json.getStringOrNull("resultSetConcurrency")) then resultSetConcurrency_.fromString(tmp) else null;
    ResultSetType? resultSetType = if (exists tmp = json.getStringOrNull("resultSetType")) then resultSetType_.fromString(tmp) else null;
    String? schema = json.getStringOrNull("schema");
    TransactionIsolation? transactionIsolation = if (exists tmp = json.getStringOrNull("transactionIsolation")) then transactionIsolation_.fromString(tmp) else null;
    return SQLOptions {
      autoGeneratedKeys = autoGeneratedKeys;
      autoGeneratedKeysIndexes = autoGeneratedKeysIndexes;
      catalog = catalog;
      fetchDirection = fetchDirection;
      fetchSize = fetchSize;
      queryTimeout = queryTimeout;
      readOnly = readOnly;
      resultSetConcurrency = resultSetConcurrency;
      resultSetType = resultSetType;
      schema = schema;
      transactionIsolation = transactionIsolation;
    };
  }

  shared object toJava extends Converter<SQLOptions, SQLOptions_>() {
    shared actual SQLOptions_ convert(SQLOptions src) {
      // Todo : make optimized version without json
      value json = JsonObject_(src.toJson().string);
      value ret = SQLOptions_(json);
      return ret;
    }
  }
  shared JsonObject toJson(SQLOptions obj) => obj.toJson();
}
